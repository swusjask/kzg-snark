from sage.all import prod

from kzg import KZG
from transcript import Transcript

class Verifier:
    """
    Marlin zkSNARK verifier implementation.
    
    The verifier checks the proof generated by the prover for an R1CS instance.
    It follows the optimized protocol described in Appendix E of the Marlin paper.
    """
    
    def __init__(self, curve_type="bn254"):
        """
        Initialize the Marlin verifier with a KZG polynomial commitment scheme.
        
        Args:
            curve_type: Type of curve to use ('bn254' or 'bls12_381')
                        Controls which elliptic curve pairing is used for the polynomial
                        commitment scheme.
        """
        # Initialize the KZG polynomial commitment scheme with specified curve
        self.kzg = KZG(curve_type=curve_type)
        
    def verify(self, ivk, x, proof):
        """
        Verify a Marlin proof for the given public input.
        
        The verification process checks that:
        1. The R1CS constraint satisfaction: A·z ○ B·z = C·z
        2. The witness consistency with the public input
        3. The integrity of all polynomial evaluations
        
        Args:
            ivk: Index verification key from the indexer containing:
                 - Verification key for polynomial commitments
                 - Commitments to constraint matrices
                 - Domain parameters for the polynomials
            x: Public input vector (the publicly known part of the witness)
            proof: Proof generated by the prover containing:
                   - Commitments to witness and auxiliary polynomials
                   - Polynomial evaluations at challenge points
                   - KZG evaluation proofs
            
        Returns:
            bool: True if the proof is valid, False otherwise
        """
        # Extract data from verification key and proof
        rk = ivk["rk"]
        index_commitments = ivk["commitments"]
        n, m = ivk["subgroups"]["n"], ivk["subgroups"]["m"]
        g_H = ivk["subgroups"]["g_H"]
        v_H, v_K = ivk["vanishing_polys"]["v_H"], ivk["vanishing_polys"]["v_K"]
        
        # Extract proof components
        first_round_commitments = proof["commitments"]["first_round"]
        second_round_commitments = proof["commitments"]["second_round"]
        third_round_commitments = proof["commitments"]["third_round"]
        evals_beta1 = proof["evaluations"]["beta1"]
        evals_beta2 = proof["evaluations"]["beta2"]
        kzg_proof_beta1 = proof["kzg_proofs"]["beta1"]
        kzg_proof_beta2 = proof["kzg_proofs"]["beta2"]
        
        # Create a transcript for the Fiat-Shamir transform
        R = self.kzg.R
        Fq = self.kzg.Fq
        transcript = Transcript("marlin-proof", Fq)
        transcript.append_message("public-inputs", x)
        
        # Recreate the transcript to generate the same challenges as the prover
        transcript.append_message("round1-commitments", first_round_commitments)
        
        # Get first round challenges
        eta_A = transcript.get_challenge("eta_A")
        eta_B = transcript.get_challenge("eta_B")
        eta_C = transcript.get_challenge("eta_C")
        alpha = transcript.get_challenge("alpha")
        
        # Add second round commitments and get challenge
        transcript.append_message("round2-commitments", second_round_commitments)
        beta_1 = transcript.get_challenge("beta_1")
        
        # Add third round commitments and get challenge
        transcript.append_message("round3-commitments", third_round_commitments)
        beta_2 = transcript.get_challenge("beta_2")
        
        # Add evaluations to transcript
        transcript.append_message("evaluations-beta1", evals_beta1)
        transcript.append_message("evaluations-beta2", evals_beta2)
        
        # Get opening challenges for batch verification
        xi_1 = transcript.get_challenge("xi_1")
        xi_2 = transcript.get_challenge("xi_2")
        
        # Extract evaluations from the proof
        [zA_beta1, t_beta1] = evals_beta1
        
        # Get commitments
        [w_comm, zA_comm, zB_comm, zC_comm, h0_comm, s_comm] = first_round_commitments
        [t_comm, g1_comm, h1_comm] = second_round_commitments
        [g2_comm, h2_comm] = third_round_commitments
        
        # Compute linearization polynomial f1, f2, f3 commitments

        # f1(x) = zA(β₁)*zB(x) - zC(x) - h_0(x)*v_H(β₁)
        f1_comm = self.kzg.multiply(zB_comm, int(zA_beta1))
        f1_comm = self.kzg.add(f1_comm, self.kzg.neg(zC_comm))
        f1_comm = self.kzg.add(f1_comm, self.kzg.multiply(h0_comm, int(-v_H(beta_1))))

        # f2(x) = s(x) + r(α, β₁)*(η_A*zA(β₁) + η_B*zB(x) + η_C*zC(x)) - t(β₁)*z(x) - h_1(x)*v_H(β₁) - β₁g_1(x)
        H_x = [g_H**i for i in range(len(x))]
        v_H_x_beta1 = prod([(beta_1 - H_x[i]) for i in range(len(x))])
        x_points = [(H_x[i], x[i]) for i in range(len(x))]
        x_poly = R.lagrange_polynomial(x_points)
        x_beta1 = x_poly(beta_1)

        z_comm = self.kzg.multiply(w_comm, int(v_H_x_beta1))
        z_comm = self.kzg.add(z_comm, self.kzg.multiply(self.kzg.G1, int(x_beta1)))

        r_alpha_beta1 = (alpha**n - beta_1**n) / (alpha - beta_1)

        f2_comm = s_comm
        temp = self.kzg.multiply(self.kzg.G1, int(eta_A * zA_beta1))
        temp = self.kzg.add(temp, self.kzg.multiply(zB_comm, int(eta_B)))
        temp = self.kzg.add(temp, self.kzg.multiply(zC_comm, int(eta_C)))
        temp = self.kzg.multiply(temp, int(r_alpha_beta1))
        f2_comm = self.kzg.add(f2_comm, temp)
        f2_comm = self.kzg.add(f2_comm, self.kzg.multiply(z_comm, int(-t_beta1)))
        f2_comm = self.kzg.add(f2_comm, self.kzg.multiply(h1_comm, int(-v_H(beta_1))))
        f2_comm = self.kzg.add(f2_comm, self.kzg.multiply(g1_comm, int(-beta_1)))

        # f3(x) = h_2(x)*v_K(β₂) - a(x) + b(β₂)*(β₂g_2(x) + t(β₁)/m)

        a_comm, b_lin = self._compute_a_b_linear(index_commitments, evals_beta2, beta_1, alpha, eta_A, eta_B, eta_C, v_H, Fq)
        f3_comm = self.kzg.multiply(h2_comm, int(v_K(beta_2)))
        f3_comm = self.kzg.add(f3_comm, self.kzg.neg(a_comm))
        temp = self.kzg.multiply(g2_comm, int(beta_2))
        temp = self.kzg.add(temp, self.kzg.multiply(self.kzg.G1, int(t_beta1 / m)))
        temp = self.kzg.multiply(temp, int(b_lin))
        f3_comm = self.kzg.add(f3_comm, temp)

        # batch verify
        beta1_commitments = [f1_comm, f2_comm, zA_comm, t_comm]
        
        beta2_commitments = [f3_comm]

        for matrix in ["A", "B", "C"]:
            for poly_type in ["row", "col"]:
                key = f"{poly_type}_{matrix}"
                beta2_commitments.append(index_commitments[key])

        beta1_evaluations = [0] * 2 + evals_beta1
        beta2_evaluations = [0] + evals_beta2

        commitment_list = [beta1_commitments, beta2_commitments]
        z_values = [beta_1, beta_2]
        evaluation_list = [beta1_evaluations, beta2_evaluations]
        proof_list = [kzg_proof_beta1, kzg_proof_beta2]
        xi_list = [xi_1, xi_2]
        batch_result = self.kzg.batch_check(rk, commitment_list, z_values, evaluation_list, proof_list, xi_list)
        
        return batch_result

    def _compute_a_b_linear(self, index_commitments, evals_beta2, beta_1, alpha, eta_A, eta_B, eta_C, v_H, Fq):
        """
        Compute the linearized commitment a and scalar value b for the verifier's final check.
        
        This method is the verifier's counterpart to the prover's _compute_a_b_linear_polynomials
        function. Instead of working with polynomials directly, it computes a commitment to the
        linearized polynomial using the KZG commitment operations.
        
        Args:
            index_commitments: Dictionary of commitments to the indexed polynomials
            evals_beta2: Evaluations of row/column polynomials at the point beta_2
            beta_1, alpha: Challenge points used in the protocol
            eta_A, eta_B, eta_C: Random challenge coefficients for each matrix
            v_H: Vanishing polynomial for domain H
            Fq: Finite field
            
        Returns:
            tuple: (a_comm, b_value) - Commitment to linearized polynomial and scalar denominator
        """
        val_A_comm, val_B_comm, val_C_comm = (
            index_commitments["val_A"],
            index_commitments["val_B"],
            index_commitments["val_C"],
        )
        
        [row_A_beta2, col_A_beta2,
         row_B_beta2, col_B_beta2,
         row_C_beta2, col_C_beta2] = evals_beta2
        
        a = self.kzg.multiply(self.kzg.G1, int(0))
        b = Fq(1)

        for matrix_idx, (eta, row, col, val) in enumerate([
            (eta_A, row_A_beta2, col_A_beta2, val_A_comm),
            (eta_B, row_B_beta2, col_B_beta2, val_B_comm),
            (eta_C, row_C_beta2, col_C_beta2, val_C_comm)
        ]):
            other_product = Fq(1)
            for other_idx, (other_row, other_col) in enumerate([
                (row_A_beta2, col_A_beta2),
                (row_B_beta2, col_B_beta2),
                (row_C_beta2, col_C_beta2)
            ]):
                if other_idx != matrix_idx:
                    other_product *= (beta_1 - other_row) * (alpha - other_col)
            

            a = self.kzg.add(a, self.kzg.multiply(val, int(eta * v_H(beta_1) * v_H(alpha) * other_product)))
            b *= (beta_1 - row) * (alpha - col)
        
        return a, b


if __name__ == "__main__":
    import pickle
    from marlin.indexer import Indexer
    from marlin.prover import Prover
    
    print("Testing Marlin Verifier")
    print("=" * 60)
    
    # Load test instance
    with open("constraint-system/R1CS_INSTANCE.pkl", "rb") as f:
        RICS_INSTANCE = pickle.load(f)
    
    A = RICS_INSTANCE["A"]
    B = RICS_INSTANCE["B"]
    C = RICS_INSTANCE["C"]
    z = RICS_INSTANCE["z"]
    
    # Define public input and witness
    x_size = 5  # Number of public inputs
    x = z[:x_size]
    w = z[x_size:]
    
    # Initialize the indexer, prover, and verifier
    indexer = Indexer(curve_type="bn254")
    prover = Prover(curve_type="bn254")
    verifier = Verifier(curve_type="bn254")
    
    # Preprocess the constraint system
    print("\nPreprocessing R1CS constraint system...")
    max_degree = 200  # Appropriate for the test instance
    ipk, ivk = indexer.preprocess(A, B, C, max_degree)
    
    # Print statistics about the processed instance
    print(f"✅ Matrix dimensions: {A.nrows()} × {A.ncols()}")
    print(f"✅ Non-zero elements: A: {len(A.nonzero_positions())}, "
          f"B: {len(B.nonzero_positions())}, C: {len(C.nonzero_positions())}")
    print(f"✅ Subgroup sizes: H: {ipk['subgroups']['n']}, K: {ipk['subgroups']['m']}")
    
    # Generate the proof
    print("\nGenerating Marlin proof...")
    proof = prover.prove(ipk, x, w)
    
    # Print proof statistics
    print(f"✅ First round commitments: {len(proof['commitments']['first_round'])}")
    print(f"✅ Second round commitments: {len(proof['commitments']['second_round'])}")
    print(f"✅ Third round commitments: {len(proof['commitments']['third_round'])}")
    
    # Verify the proof
    print("\nVerifying Marlin proof...")
    result = verifier.verify(ivk, x, proof)
    
    print(f"\n{'✅' if result else '❌'} Proof verification: {result}")
    
    # Test with a tampered proof if verification succeeded
    if result:
        print("\nTesting with tampered proof...")
        # Make a backup of the original value
        original_value = proof["evaluations"]["beta1"][0]
        
        # Tamper with the proof by modifying an evaluation
        proof["evaluations"]["beta1"][0] = (original_value + 1) % verifier.kzg.curve_order
        
        # Verify the tampered proof (should fail)
        tampered_result = verifier.verify(ivk, x, proof)
        print(f"{'✅' if not tampered_result else '❌'} Tampered proof rejected: {not tampered_result}")
        
        # Restore the original value
        proof["evaluations"]["beta1"][0] = original_value
    
    print("\n✅ Marlin Verifier test completed successfully!")
