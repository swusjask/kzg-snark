import sys, os
from sage.all import prod

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from kzg import KZG
from transcript import Transcript

class Verifier:
    """
    Marlin zkSNARK verifier implementation.
    
    The verifier checks the proof generated by the prover for an R1CS instance.
    It follows the optimized protocol described in Appendix E of the Marlin paper.
    """
    
    def __init__(self, curve_type="bn254"):
        """
        Initialize the Marlin verifier with a KZG polynomial commitment scheme.
        
        Args:
            curve_type: Type of curve to use ('bn254' or 'bls12_381')
        """
        self.kzg = KZG(curve_type=curve_type)
        
    def verify(self, ivk, x, proof):
        """
        Verify a Marlin proof for the given public input.
        
        Args:
            ivk: Index verification key from the indexer
            x: Public input
            proof: Proof generated by the prover
            
        Returns:
            bool: True if the proof is valid, False otherwise
        """
        # Extract data from verification key and proof
        rk = ivk["rk"]
        index_commitments = ivk["commitments"]
        n, m = ivk["subgroups"]["n"], ivk["subgroups"]["m"]
        g_H = ivk["subgroups"]["g_H"]
        
        # Extract proof components
        first_round_commitments = proof["commitments"]["first_round"]
        second_round_commitments = proof["commitments"]["second_round"]
        third_round_commitments = proof["commitments"]["third_round"]
        evals_beta1 = proof["evaluations"]["beta1"]
        evals_beta2 = proof["evaluations"]["beta2"]
        kzg_proof_beta1 = proof["kzg_proofs"]["beta1"]
        kzg_proof_beta2 = proof["kzg_proofs"]["beta2"]
        
        # Create a transcript for the Fiat-Shamir transform
        R = self.kzg.R
        Fq = self.kzg.Fq
        transcript = Transcript("marlin-proof", Fq)
        transcript.append_message("public-inputs", x)
        
        # Recreate the transcript to generate the same challenges as the prover
        transcript.append_message("round1-commitments", first_round_commitments)
        
        # Get first round challenges
        eta_A = transcript.get_challenge("eta_A")
        eta_B = transcript.get_challenge("eta_B")
        eta_C = transcript.get_challenge("eta_C")
        alpha = transcript.get_challenge("alpha")
        
        # Add second round commitments and get challenge
        transcript.append_message("round2-commitments", second_round_commitments)
        beta_1 = transcript.get_challenge("beta_1")
        
        # Add third round commitments and get challenge
        transcript.append_message("round3-commitments", third_round_commitments)
        beta_2 = transcript.get_challenge("beta_2")
        
        # Add evaluations to transcript
        transcript.append_message("evaluations-beta1", evals_beta1)
        transcript.append_message("evaluations-beta2", evals_beta2)
        
        # Get opening challenges for batch verification
        xi_1 = transcript.get_challenge("xi_1")
        xi_2 = transcript.get_challenge("xi_2")
        
        # Extract evaluations from the proof
        [w_beta1, zA_beta1, zB_beta1, zC_beta1, h0_beta1, s_beta1, 
         t_beta1, g1_beta1, h1_beta1] = evals_beta1
        
        # The first two elements in evals_beta2 are g2(β₂) and h2(β₂)
        g2_beta2 = evals_beta2[0]
        h2_beta2 = evals_beta2[1]
        
        # The remaining elements are the evaluations of the 9 indexer polynomials at β₂
        [row_A_beta2, col_A_beta2, val_A_beta2,
         row_B_beta2, col_B_beta2, val_B_beta2,
         row_C_beta2, col_C_beta2, val_C_beta2] = evals_beta2[2:11]
        
        # Get commitments
        [w_comm, zA_comm, zB_comm, zC_comm, h0_comm, s_comm] = first_round_commitments
        [t_comm, g1_comm, h1_comm] = second_round_commitments
        [g2_comm, h2_comm] = third_round_commitments
        
        # Verify polynomial relations
        # 1. Check entry-wise product: zA(β₁)·zB(β₁) - zC(β₁) = h₀(β₁)·v_H(β₁)
        v_H_beta1 = beta_1**n - 1  # v_H(β₁) = β₁^n - 1
        if zA_beta1 * zB_beta1 - zC_beta1 != h0_beta1 * v_H_beta1:
            print("❌ Entry-wise product check failed")
            return False
        
        # 2. Check first sumcheck: s(β₁) + r(α,β₁)(Σ η_M·z_M(β₁)) - t(β₁)·z(β₁) = h₁(β₁)·v_H(β₁) + β₁·g₁(β₁)
        # First compute r(α,β₁) which is u_H(α,β₁) = (α^n - β₁^n)/(α - β₁)
        r_alpha_beta1 = (alpha**n - beta_1**n) / (alpha - beta_1)
        
        H_x = [g_H**i for i in range(len(x))]
        # Compute z(β₁) from w(β₁)
        # For verification, we need to compute x_poly(β₁)
        # Since x_poly depends on the public input, we reconstruct it
        # First, we compute v_H_x (vanishing polynomial for H[:len(x)])
        v_H_x_beta1 = prod([(beta_1 - H_x[i]) for i in range(len(x))])
        
        # Compute x_poly(β₁) using the public input x
        # This is a simple approximation - in practice we would need to 
        # compute the Lagrange basis polynomials properly
        x_points = [(H_x[i], x[i]) for i in range(len(x))]
        x_poly = R.lagrange_polynomial(x_points)
        x_poly_beta1 = x_poly(beta_1)
        
        # Compute z(β₁) = w(β₁)·v_H_x(β₁) + x_poly(β₁)
        z_beta1 = w_beta1 * v_H_x_beta1 + x_poly_beta1
        
        # Check the first sumcheck relation
        sumcheck1 = s_beta1 + r_alpha_beta1 * (eta_A * zA_beta1 + eta_B * zB_beta1 + eta_C * zC_beta1) - t_beta1 * z_beta1
        expected_sumcheck1 = h1_beta1 * v_H_beta1 + beta_1 * g1_beta1
        
        if sumcheck1 != expected_sumcheck1:
            print("❌ First sumcheck relation failed")
            return False
        
        # 3. Check second sumcheck relation with evaluations at β₂
        v_K_beta2 = beta_2**m - 1  # v_K(β₂) = β₂^m - 1
        v_H_beta1 = beta_1**n - 1  # v_H(β₁) = β₁^n - 1
        v_H_alpha = alpha**n - 1   # v_H(α) = α^n - 1
        
        # Now we can compute a(β₂) and b(β₂) using the indexed polynomial evaluations
        
        # For a(β₂), we compute:
        # a(β₂) = Σ_{M∈{A,B,C}} η_M · v_H(β₁)·v_H(α)·val_M(β₂) · Π_{N≠M} (β₁-row_N(β₂))·(α-col_N(β₂))
        
        # Term for matrix A
        term_A_other_prod = ((beta_1 - row_B_beta2) * (alpha - col_B_beta2) * 
                             (beta_1 - row_C_beta2) * (alpha - col_C_beta2))
        term_A = eta_A * v_H_beta1 * v_H_alpha * val_A_beta2 * term_A_other_prod
        
        # Term for matrix B
        term_B_other_prod = ((beta_1 - row_A_beta2) * (alpha - col_A_beta2) * 
                             (beta_1 - row_C_beta2) * (alpha - col_C_beta2))
        term_B = eta_B * v_H_beta1 * v_H_alpha * val_B_beta2 * term_B_other_prod
        
        # Term for matrix C
        term_C_other_prod = ((beta_1 - row_A_beta2) * (alpha - col_A_beta2) * 
                             (beta_1 - row_B_beta2) * (alpha - col_B_beta2))
        term_C = eta_C * v_H_beta1 * v_H_alpha * val_C_beta2 * term_C_other_prod
        
        a_beta2 = term_A + term_B + term_C
        
        # For b(β₂), we compute:
        # b(β₂) = Π_{M∈{A,B,C}} (β₁-row_M(β₂))·(α-col_M(β₂))
        b_beta2 = ((beta_1 - row_A_beta2) * (alpha - col_A_beta2) * 
                   (beta_1 - row_B_beta2) * (alpha - col_B_beta2) * 
                   (beta_1 - row_C_beta2) * (alpha - col_C_beta2))
        
        # Check the second sumcheck relation:
        # a(β₂) - b(β₂)·(β₂·g₂(β₂) + t(β₁)/m) = h₂(β₂)·v_K(β₂)
        second_sumcheck = a_beta2 - b_beta2 * (beta_2 * g2_beta2 + t_beta1/m)
        expected_second_sumcheck = h2_beta2 * v_K_beta2
        
        if second_sumcheck != expected_second_sumcheck:
            print("❌ Second sumcheck relation failed")
            print(f"   Computed: {second_sumcheck}")
            print(f"   Expected: {expected_second_sumcheck}")
            return False
        
        # Verify KZG proofs
        # 1. Verify proof for evaluations at β₁
        beta1_commitments = [w_comm, zA_comm, zB_comm, zC_comm, h0_comm, s_comm, 
                             t_comm, g1_comm, h1_comm]
        if not self.kzg.check(rk, beta1_commitments, beta_1, evals_beta1, kzg_proof_beta1, xi_1):
            print("❌ KZG proof verification failed for β₁")
            return False
        
        # 2. Verify proof for all evaluations at β₂ (including indexer polynomials)
        beta2_commitments = [g2_comm, h2_comm] + index_commitments
        if not self.kzg.check(rk, beta2_commitments, beta_2, evals_beta2, kzg_proof_beta2, xi_2):
            print("❌ KZG proof verification failed for β₂")
            return False
        
        # All checks passed
        return True


if __name__ == "__main__":
    import pickle
    from indexer import Indexer
    from prover import Prover
    
    print("Testing Marlin Verifier")
    print("=" * 60)
    
    # Load a test R1CS instance
    with open("R1CS_INSTANCE.pkl", "rb") as f:
        RICS_INSTANCE = pickle.load(f)
    A, B, C, z = RICS_INSTANCE["A"], RICS_INSTANCE["B"], RICS_INSTANCE["C"], RICS_INSTANCE["z"]
    
    # Define public input (first few elements) and witness (remaining elements)
    x_size = 5  # Adjust this based on your test instance
    x = z[:x_size]
    w = z[x_size:]
    
    # Initialize the indexer, prover, and verifier
    indexer = Indexer(curve_type="bn254")
    prover = Prover(curve_type="bn254")
    verifier = Verifier(curve_type="bn254")
    
    # Determine maximum degree needed
    max_degree = 200  # Adjust based on your specific instance
    
    # Preprocess the constraint system
    print("\nPreprocessing constraint system...")
    ipk, ivk = indexer.preprocess(A, B, C, max_degree)
    
    # Generate the proof
    print("\nGenerating proof...")
    proof = prover.prove(ipk, x, w)
    
    # Verify the proof
    print("\nVerifying proof...")
    result = verifier.verify(ivk, x, proof)
    
    print(f"\n{'✅' if result else '❌'} Proof verification: {result}")
    
    if result:
        print("\nTesting tampered proof...")
        # Tamper with one of the evaluations
        proof["evaluations"]["beta1"][0] = (proof["evaluations"]["beta1"][0] + 1) % verifier.kzg.curve_order
        tampered_result = verifier.verify(ivk, x, proof)
        print(f"{'✅' if not tampered_result else '❌'} Tampered proof verification (should fail): {tampered_result}")