import sys, os

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from kzg import KZG
from encoder import Encoder
from transcript import Transcript

class Verifier:
    """
    PLONK zkSNARK verifier implementation.
    
    The verifier checks the validity of proofs generated by the PLONK prover.
    It follows the verification algorithm described in section 8.3 of the PLONK paper,
    using polynomial commitments and pairing-based verification for efficiency.
    """
    
    def __init__(self, curve_type="bn254"):
        """
        Initialize the PLONK verifier with a KZG polynomial commitment scheme.
        
        Args:
            curve_type: Type of curve to use ('bn254' or 'bls12_381')
        """
        self.kzg = KZG(curve_type=curve_type)
        
    def verify(self, ivk, x, proof):
        """
        Verify a PLONK proof for the given public input.
        
        Args:
            ivk: Index verification key from the indexer
            x: Public input list
            proof: Proof generated by the prover
            
        Returns:
            bool: True if the proof is valid, False otherwise
        """
        # Extract data from verification key
        rk = ivk["rk"]
        commitments = ivk["commitments"]
        n = ivk["subgroups"]["n"]
        g = ivk["subgroups"]["g"]
        k1 = ivk["subgroups"]["k1"]
        k2 = ivk["subgroups"]["k2"]
        
        # Extract proof components
        wire_commitments = [
            proof["commitments"]["a"],
            proof["commitments"]["b"],
            proof["commitments"]["c"]
        ]
        z_comm = proof["commitments"]["z"]
        quotient_commitments = [
            proof["commitments"]["t_lo"],
            proof["commitments"]["t_mid"],
            proof["commitments"]["t_hi"]
        ]
        W_z = proof["commitments"]["W_z"]
        W_zw = proof["commitments"]["W_zw"]
        
        # Extract evaluations
        a_zeta = proof["evaluations"]["a"]
        b_zeta = proof["evaluations"]["b"]
        c_zeta = proof["evaluations"]["c"]
        s_sigma1_zeta = proof["evaluations"]["s_sigma1"]
        s_sigma2_zeta = proof["evaluations"]["s_sigma2"]
        z_omega_zeta = proof["evaluations"]["z_omega"]
        
        # Extract selector and permutation commitments
        qM_comm = commitments["qM"]
        qL_comm = commitments["qL"]
        qR_comm = commitments["qR"]
        qO_comm = commitments["qO"]
        qC_comm = commitments["qC"]
        s_sigma1_comm = commitments["S_sigma1"]
        s_sigma2_comm = commitments["S_sigma2"]
        s_sigma3_comm = commitments["S_sigma3"]
        
        # Set up field
        Fq = self.kzg.Fq

        # Create encoder for public input polynomial
        self.encoder = Encoder(self.kzg.curve_order)
        empty_perm = [0] * (3 * n)
        empty_selectors = [Fq(0)] * n
        self.encoder.update_state(empty_selectors, empty_selectors, empty_selectors, empty_selectors, empty_selectors, empty_perm)
        
        # Compute public input polynomial
        PI = self.encoder.compute_public_input_poly(x)
        
        # Create a transcript for the Fiat-Shamir transform
        transcript = Transcript("plonk-proof", Fq)
        
        # Add public inputs to the transcript
        transcript.append_message("public-inputs", x)
        
        # Recreate the transcript to recover the same challenges as the prover
        transcript.append_message("round1-commitments", wire_commitments)
        
        # Get permutation challenges
        beta = transcript.get_challenge("beta")
        gamma = transcript.get_challenge("gamma")
        
        # Add permutation commitment
        transcript.append_message("round2-commitment", z_comm)
        
        # Get quotient challenge
        alpha = transcript.get_challenge("alpha")
        
        # Add quotient commitments
        transcript.append_message("round3-commitments", quotient_commitments)
        
        # Get evaluation challenge
        zeta = transcript.get_challenge("zeta")
        
        # Add evaluations
        evaluations = [a_zeta, b_zeta, c_zeta, s_sigma1_zeta, s_sigma2_zeta, z_omega_zeta]
        transcript.append_message("round4-evaluations", evaluations)
        
        # Get opening challenge
        v = transcript.get_challenge("v")
        
        # Get multipoint evaluation challenge (for batch verification)
        u = transcript.get_challenge("u")
        
        # Calculate ZH(zeta) = zeta^n - 1
        ZH_zeta = zeta**n - 1
        
        # Calculate L1(zeta) = (zeta^n - 1)/(n*(zeta - 1))
        L1_zeta = (zeta**n - 1)/(n * (zeta - 1))
        
        # Calculate PI(zeta) - public input polynomial evaluation
        PI_zeta = PI(zeta)
        
        # Compute linearization polynomial r(X) commitment
        # First term: a_zeta * b_zeta * qM(X) + a_zeta * qL(X) + b_zeta * qR(X) + c_zeta * qO(X) + PI(zeta) + qC(X)
        r_comm = self.kzg.multiply(qM_comm, int(a_zeta * b_zeta))
        r_comm = self.kzg.add(r_comm, self.kzg.multiply(qL_comm, int(a_zeta)))
        r_comm = self.kzg.add(r_comm, self.kzg.multiply(qR_comm, int(b_zeta)))
        r_comm = self.kzg.add(r_comm, self.kzg.multiply(qO_comm, int(c_zeta)))
        r_comm = self.kzg.add(r_comm, self.kzg.multiply(self.kzg.G1, int(PI_zeta)))
        r_comm = self.kzg.add(r_comm, qC_comm)

        # Permutation constraint terms (α term)
        # Step 1: Compute (a_zeta + β·z + γ)(b_zeta + β·k1·z + γ)(c_zeta + β·k2·z + γ)·z(X)
        a_term_1 = a_zeta + beta * zeta + gamma
        b_term_1 = b_zeta + beta * k1 * zeta + gamma
        c_term_1 = c_zeta + beta * k2 * zeta + gamma
        factor_1 = a_term_1 * b_term_1 * c_term_1
        term_1 = self.kzg.multiply(z_comm, int(factor_1))

        # Step 2: Compute (c_zeta + β·S_σ3(X) + γ)
        c_poly_term = self.kzg.multiply(s_sigma3_comm, int(beta))  # β·S_σ3(X)
        c_poly_term = self.kzg.add(c_poly_term, self.kzg.multiply(self.kzg.G1, int(c_zeta + gamma)))  # c_zeta + β·S_σ3(X) + γ

        # Step 3: Compute (a_zeta + β·s_σ1_zeta + γ)(b_zeta + β·s_σ2_zeta + γ)(c_zeta + β·S_σ3(X) + γ)·z_ω_zeta
        a_term_2 = a_zeta + beta * s_sigma1_zeta + gamma
        b_term_2 = b_zeta + beta * s_sigma2_zeta + gamma
        factor_2 = a_term_2 * b_term_2 * z_omega_zeta
        term_2 = self.kzg.multiply(c_poly_term, int(factor_2))

        # Step 4: Compute term_1 - term_2
        perm_diff = self.kzg.add(term_1, self.kzg.neg(term_2))

        # Step 5: Multiply by α
        perm_term = self.kzg.multiply(perm_diff, int(alpha))

        # Add permutation term to r_comm
        r_comm = self.kzg.add(r_comm, perm_term)

        # Add copy constraint term: α²*[(z(X) - 1)*L1(zeta)]
        factor3 = alpha**2 * L1_zeta
        z_minus_1 = self.kzg.add(z_comm, self.kzg.neg(self.kzg.G1))
        r_comm = self.kzg.add(r_comm, self.kzg.multiply(z_minus_1, int(factor3)))

        # Subtract quotient polynomial terms: -ZH(zeta)*(t_lo(X) + zeta^n*t_mid(X) + zeta^(2n)*t_hi(X))
        t_combined = self.kzg.add(proof["commitments"]["t_lo"], 
                                 self.kzg.multiply(proof["commitments"]["t_mid"], int(zeta**n)))
        t_combined = self.kzg.add(t_combined, 
                                 self.kzg.multiply(proof["commitments"]["t_hi"], int(zeta**(2*n))))
        r_comm = self.kzg.add(r_comm, self.kzg.neg(self.kzg.multiply(t_combined, int(ZH_zeta))))

        # Prepare polynomials and evaluations for verification
        # First batch: Polynomials evaluated at zeta
        zeta_commitments = [
            r_comm,           # r(X) (linearization polynomial)
            wire_commitments[0],  # a(X)
            wire_commitments[1],  # b(X)
            wire_commitments[2],  # c(X)
            s_sigma1_comm,    # S_sigma1(X)
            s_sigma2_comm     # S_sigma2(X)
        ]
        
        # Evaluations at zeta
        zeta_evaluations = [
            Fq(0),            # r(zeta) = 0
            a_zeta,           # a(zeta)
            b_zeta,           # b(zeta)
            c_zeta,           # c(zeta)
            s_sigma1_zeta,    # S_sigma1(zeta)
            s_sigma2_zeta     # S_sigma2(zeta)
        ]
        
        # Second batch: Polynomial z(X) evaluated at zeta * g
        zw_commitments = [z_comm]
        zw_evaluations = [z_omega_zeta]
        
        # Verify batch opening proofs
        commitment_list = [zeta_commitments, zw_commitments]
        z_values = [zeta, zeta * g]
        evaluations_list = [zeta_evaluations, zw_evaluations]
        proof_list = [W_z, W_zw]
        xi_values = [v] * 2
        batch_result = self.kzg.batch_check(rk, commitment_list, z_values, evaluations_list, proof_list, xi_values, u)

        return batch_result


if __name__ == "__main__":
    import pickle
    from indexer import Indexer
    from prover import Prover
    
    print("Testing PLONK Verifier")
    print("=" * 60)
    
    # Load the PLONK arithmetization instance
    with open("PLONK_ARITHMETIZATION_INSTANCE.pkl", "rb") as f:
        instance = pickle.load(f)
    
    # Extract instance data
    qM = instance["qM"]
    qL = instance["qL"]
    qR = instance["qR"]
    qO = instance["qO"]
    qC = instance["qC"]
    perm = instance["perm"]
    w = instance["w"]
    
    # Define public input and witness
    x_size = 5  # Number of public inputs
    x = w[:x_size]
    witness = w[x_size:]
    
    # Initialize all components
    indexer = Indexer(curve_type="bn254")
    prover = Prover(curve_type="bn254")
    verifier = Verifier(curve_type="bn254")
    
    # Preprocess the circuit
    print("\nPreprocessing PLONK circuit...")
    n = len(qM)
    max_degree = n + 5  # For PLONK, max_degree depends on highest degree polynomial
    ipk, ivk = indexer.preprocess(qM, qL, qR, qO, qC, perm, max_degree)
    
    # Print statistics about the circuit
    print(f"✅ Circuit size: {n} gates")
    print(f"✅ Public inputs: {x_size}")
    print(f"✅ Witness size: {len(witness)}")
    print(f"✅ Number of selector polynomials: 5")
    print(f"✅ Number of permutation polynomials: 3")
    
    # Generate the proof
    print("\nGenerating PLONK proof...")
    proof = prover.prove(ipk, x, witness)
    
    # Print proof statistics
    print(f"✅ Wire commitments: 3")
    print(f"✅ Permutation commitment: 1")
    print(f"✅ Quotient commitments: 3")
    print(f"✅ Opening proof commitments: 2")
    
    # Verify the proof
    print("\nVerifying PLONK proof...")
    result = verifier.verify(ivk, x, proof)
    
    print(f"\n{'✅' if result else '❌'} Proof verification: {result}")
    
    # Test with a tampered proof if verification succeeded
    if result:
        print("\nTesting with tampered proof...")
        # Make a backup of the original value
        original_value = proof["evaluations"]["a"]
        
        # Tamper with the proof by modifying an evaluation
        proof["evaluations"]["a"] = (original_value + 1) % verifier.kzg.curve_order
        
        # Verify the tampered proof (should fail)
        tampered_result = verifier.verify(ivk, x, proof)
        print(f"{'✅' if not tampered_result else '❌'} Tampered proof rejected: {not tampered_result}")
        
        # Restore the original value
        proof["evaluations"]["a"] = original_value
    
    print("\n✅ PLONK Verifier test completed successfully!")
