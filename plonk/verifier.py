import sys, os

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from kzg import KZG
from encoder import Encoder
from transcript import Transcript

class Verifier:
    """
    PLONK zkSNARK verifier implementation.
    
    The verifier checks the proof generated by the prover for a PLONK circuit.
    It follows the verification algorithm described in section 8.3 of the PLONK paper.
    """
    
    def __init__(self, curve_type="bn254"):
        """
        Initialize the PLONK verifier with a KZG polynomial commitment scheme.
        
        Args:
            curve_type: Type of curve to use ('bn254' or 'bls12_381')
        """
        self.kzg = KZG(curve_type=curve_type)
        
    def verify(self, ivk, x, proof):
        """
        Verify a PLONK proof for the given public input.
        
        Args:
            ivk: Index verification key from the indexer
            x: Public input
            proof: Proof generated by the prover
            
        Returns:
            bool: True if the proof is valid, False otherwise
        """
        # Extract data from verification key
        rk = ivk["rk"]
        n = ivk["subgroups"]["n"]
        g = ivk["subgroups"]["g"]
        k1 = ivk["subgroups"]["k1"]
        k2 = ivk["subgroups"]["k2"]
        
        # Extract commitments from proof
        a_comm = proof["commitments"]["a"]
        b_comm = proof["commitments"]["b"]
        c_comm = proof["commitments"]["c"]
        z_comm = proof["commitments"]["z"]
        t_lo_comm = proof["commitments"]["t_lo"]
        t_mid_comm = proof["commitments"]["t_mid"]
        t_hi_comm = proof["commitments"]["t_hi"]
        W_z = proof["commitments"]["W_z"]
        W_zw = proof["commitments"]["W_zw"]
        
        # Extract evaluations from proof
        a_zeta = proof["evaluations"]["a"]
        b_zeta = proof["evaluations"]["b"]
        c_zeta = proof["evaluations"]["c"]
        s_sigma1_zeta = proof["evaluations"]["s_sigma1"]
        s_sigma2_zeta = proof["evaluations"]["s_sigma2"]
        z_omega_zeta = proof["evaluations"]["z_omega"]
        
        # Extract index commitments
        qM_comm = ivk["commitments"]["qM"]
        qL_comm = ivk["commitments"]["qL"]
        qR_comm = ivk["commitments"]["qR"]
        qO_comm = ivk["commitments"]["qO"]
        qC_comm = ivk["commitments"]["qC"]
        s_sigma1_comm = ivk["commitments"]["S_sigma1"]
        s_sigma2_comm = ivk["commitments"]["S_sigma2"]
        s_sigma3_comm = ivk["commitments"]["S_sigma3"]
        
        # Field setup
        Fq = self.kzg.Fq

        self.encoder = Encoder(self.kzg.curve_order)
        empty_perm = [0] * (3 * n)
        empty_selectors = [Fq(0)] * n
        self.encoder.update_state(empty_selectors, empty_selectors, empty_selectors, empty_selectors, empty_selectors, empty_perm)
        
        # Compute public input polynomial
        PI = self.encoder.compute_public_input_poly(x)
        
        # Create a transcript for the Fiat-Shamir transform
        transcript = Transcript("plonk-proof", Fq)
        
        # Add public inputs to the transcript
        transcript.append_message("public-inputs", x)
        
        # Recreate the transcript to generate the same challenges as the prover
        # Round 1: Add first round commitments
        first_round_commitments = [a_comm, b_comm, c_comm]
        transcript.append_message("round1-commitments", first_round_commitments)
        
        # Get permutation challenges
        beta = transcript.get_challenge("beta")
        gamma = transcript.get_challenge("gamma")
        
        # Round 2: Add second round commitment (z)
        transcript.append_message("round2-commitment", z_comm)
        
        # Get quotient challenge
        alpha = transcript.get_challenge("alpha")
        
        # Round 3: Add third round commitments (t_lo, t_mid, t_hi)
        third_round_commitments = [t_lo_comm, t_mid_comm, t_hi_comm]
        transcript.append_message("round3-commitments", third_round_commitments)
        
        # Get evaluation challenge
        zeta = transcript.get_challenge("zeta")
        
        # Round 4: Add evaluations
        evaluations = [a_zeta, b_zeta, c_zeta, s_sigma1_zeta, s_sigma2_zeta, z_omega_zeta]
        transcript.append_message("round4-evaluations", evaluations)
        
        # Get opening challenge
        v = transcript.get_challenge("v")
        
        # Get multipoint evaluation challenge (not used in separate checks, but included for completeness)
        u = transcript.get_challenge("u")
        
        # Calculate ZH(zeta) = zeta^n - 1
        ZH_zeta = zeta**n - 1
        
        # Calculate L1(zeta) = (zeta^n - 1)/(n*(zeta - 1))
        L1_zeta = (zeta**n - 1)/(n * (zeta - 1))
        
        # Calculate PI(zeta) - public input polynomial evaluation
        PI_zeta = PI(zeta)
        
        # Compute linearization polynomial r(X) commitment
        # First term: a_zeta * b_zeta * qM(X) + a_zeta * qL(X) + b_zeta * qR(X) + c_zeta * qO(X) + PI(zeta) + qC(X)
        r_comm = self.kzg.multiply(qM_comm, int(a_zeta * b_zeta))
        r_comm = self.kzg.add(r_comm, self.kzg.multiply(qL_comm, int(a_zeta)))
        r_comm = self.kzg.add(r_comm, self.kzg.multiply(qR_comm, int(b_zeta)))
        r_comm = self.kzg.add(r_comm, self.kzg.multiply(qO_comm, int(c_zeta)))
        r_comm = self.kzg.add(r_comm, self.kzg.multiply(self.kzg.G1, int(PI_zeta)))
        r_comm = self.kzg.add(r_comm, qC_comm)

        # Permutation constraint terms (α term)
        # Step 1: Compute (a_zeta + βz + γ)(b_zeta + βk1z + γ)(c_zeta + βk2z + γ)·z(X)
        a_term_1 = a_zeta + beta * zeta + gamma
        b_term_1 = b_zeta + beta * k1 * zeta + gamma
        c_term_1 = c_zeta + beta * k2 * zeta + gamma
        factor_1 = a_term_1 * b_term_1 * c_term_1
        term_1 = self.kzg.multiply(z_comm, int(factor_1))

        # Step 2: Compute (c_zeta + β·Sσ3(X) + γ)
        c_poly_term = self.kzg.multiply(s_sigma3_comm, int(beta))  # β·Sσ3(X)
        c_poly_term = self.kzg.add(c_poly_term, self.kzg.multiply(self.kzg.G1, int(c_zeta + gamma)))  # c_zeta + β·Sσ3(X) + γ

        # Step 3: Compute (a_zeta + β·sσ1 + γ)(b_zeta + β·sσ2 + γ)(c_zeta + β·Sσ3(X) + γ)·zω
        a_term_2 = a_zeta + beta * s_sigma1_zeta + gamma
        b_term_2 = b_zeta + beta * s_sigma2_zeta + gamma
        factor_2 = a_term_2 * b_term_2 * z_omega_zeta
        term_2 = self.kzg.multiply(c_poly_term, int(factor_2))

        # Step 4: Compute term_1 - term_2
        perm_diff = self.kzg.add(term_1, self.kzg.neg(term_2))

        # Step 5: Multiply by α
        perm_term = self.kzg.multiply(perm_diff, int(alpha))

        # Add permutation term to r_comm
        r_comm = self.kzg.add(r_comm, perm_term)

        # Add the remaining terms...
        # Fourth term: α²*[(z(X) - 1)*L1(zeta)]
        factor3 = alpha**2 * L1_zeta
        z_minus_1 = self.kzg.add(z_comm, self.kzg.neg(self.kzg.G1))
        r_comm = self.kzg.add(r_comm, self.kzg.multiply(z_minus_1, int(factor3)))

        # Fifth term: -ZH(zeta)*(t_lo(X) + zeta^n*t_mid(X) + zeta^(2n)*t_hi(X))
        t_combined = self.kzg.add(t_lo_comm, self.kzg.multiply(t_mid_comm, int(zeta**n)))
        t_combined = self.kzg.add(t_combined, self.kzg.multiply(t_hi_comm, int(zeta**(2*n))))
        r_comm = self.kzg.add(r_comm, self.kzg.neg(self.kzg.multiply(t_combined, int(ZH_zeta))))

        # Prepare commitments and evaluations for the first KZG check
        # Polynomials evaluated at zeta
        zeta_commitments = [
            r_comm,           # r(X) (linearization polynomial)
            a_comm,           # a(X)
            b_comm,           # b(X)
            c_comm,           # c(X)
            s_sigma1_comm,    # S_sigma1(X)
            s_sigma2_comm     # S_sigma2(X)
        ]
        
        # Evaluations at zeta
        zeta_evaluations = [
            Fq(0),            # r(zeta) = 0
            a_zeta,           # a(zeta)
            b_zeta,           # b(zeta)
            c_zeta,           # c(zeta)
            s_sigma1_zeta,    # S_sigma1(zeta)
            s_sigma2_zeta     # S_sigma2(zeta)
        ]
        
        # Prepare commitments and evaluations for the second KZG check
        # Polynomial z(X) evaluated at zeta * g
        zw_commitments = [z_comm]
        zw_evaluations = [z_omega_zeta]
        
        # Verify both opening proofs separately
        # 1. Verify polynomials evaluated at zeta
        result1 = self.kzg.check(rk, zeta_commitments, zeta, zeta_evaluations, W_z, v)
        
        # 2. Verify z(X) evaluated at zeta * g
        result2 = self.kzg.check(rk, zw_commitments, zeta * g, zw_evaluations, W_zw, v)
        # Both checks must pass for the proof to be valid
        return result1 and result2


if __name__ == "__main__":
    import pickle
    from indexer import Indexer
    from prover import Prover
    
    print("Testing PLONK Verifier")
    print("=" * 60)
    
    # Load the PLONK arithmetization instance
    with open("PLONK_ARITHMETIZATION_INSTANCE.pkl", "rb") as f:
        instance = pickle.load(f)
        
    qM = instance["qM"]
    qL = instance["qL"]
    qR = instance["qR"]
    qO = instance["qO"]
    qC = instance["qC"]
    perm = instance["perm"]
    w = instance["w"]
    
    # Define public input (first few elements) and witness (remaining elements)
    x_size = 5  # Adjust based on your instance
    x = w[:x_size]
    remaining_w = w[x_size:]
    
    # Initialize the indexer, prover, and verifier
    indexer = Indexer(curve_type="bn254")
    prover = Prover(curve_type="bn254")
    verifier = Verifier(curve_type="bn254")
    
    # Determine maximum degree needed
    n = len(qM)
    max_degree = n + 5  # For PLONK, max_degree depends on highest degree polynomial
    
    # Preprocess the circuit
    print("\nPreprocessing PLONK circuit...")
    ipk, ivk = indexer.preprocess(qM, qL, qR, qO, qC, perm, max_degree)
    
    # Generate the proof
    print("\nGenerating proof...")
    proof = prover.prove(ipk, x, remaining_w)
    
    # Verify the proof
    print("\nVerifying proof...")
    result = verifier.verify(ivk, x, proof)
    
    print(f"\n{'✅' if result else '❌'} Proof verification: {result}")
    
    if result:
        print("\nTesting tampered proof...")
        # Tamper with one of the evaluations
        proof["evaluations"]["a"] = (proof["evaluations"]["a"] + 1) % verifier.kzg.curve_order
        tampered_result = verifier.verify(ivk, x, proof)
        print(f"{'✅' if not tampered_result else '❌'} Tampered proof verification (should fail): {tampered_result}")
